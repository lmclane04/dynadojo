import numpy as np
from scipy.stats.qmc import LatinHypercube
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import pywt


def compute_complexity(system, timesteps, complexity_func):
    """
    Compute the average complexity for multiple trajectories generated by the system.
    """
    # Generate initial conditions and data trajectories
    x0 = system.make_init_conds(10)
    x = system.make_data(x0, timesteps=timesteps)
    
    # Calculate complexity for each trajectory and return the mean
    complexities = [complexity_func(x[i, :, :]) for i in range(10)]
    return np.mean(complexities)


def refine_sampling(param_samples, complexities, jump_threshold=0.1):
    """
    Refine sampling by adding midpoints between parameters where large jumps in complexity occur.
    """
    # Identify jumps in complexity values
    jumps = np.diff(complexities)
    jump_indices = np.where(np.abs(jumps) > jump_threshold)[0]
    
    # Start with existing samples
    refined_samples = set(param_samples)
    
    # Add midpoints where jumps are detected
    for index in jump_indices:
        if index + 1 < len(param_samples):
            midpoint = (param_samples[index] + param_samples[index + 1]) / 2
            refined_samples.add(midpoint)
    
    return np.array(list(refined_samples))


def explore_parameter_space_adaptively(system_checker, n_initial_samples, max_iters, timesteps, complexity_func, jump_threshold=0.1, threshold=0.01):
    """
    Explore parameter space adaptively by refining sampling based on complexity jumps and stopping when improvements are minimal.
    """
    complexity_cache = {}
    
    def compute_or_get_complexity(param):
        # Retrieve precomputed complexity if available
        if param in complexity_cache:
            return complexity_cache[param]
        # Update system with new parameter and compute complexity
        system_checker._system.update_params({'rho': param})
        complexity = compute_complexity(system_checker, timesteps, complexity_func)
        complexity_cache[param] = complexity
        return complexity

    # Initial sampling using Latin Hypercube
    lhs = LatinHypercube(d=1)
    lhs_samples = lhs.random(n_initial_samples).flatten()
    lhs_samples = np.concatenate(([0], lhs_samples, [1]))  # Add boundary points
    param_samples = 0 + (50 - 0) * lhs_samples

    print(f"Initial param samples: {param_samples}")

    # Compute complexities for initial samples
    complexities = [compute_or_get_complexity(param) for param in param_samples]
    complexities = np.array(complexities)
    
    for iteration in range(max_iters):
        # Sort samples and complexities
        sorted_indices = np.argsort(param_samples)
        param_samples = np.array(param_samples)[sorted_indices]
        complexities = np.array(complexities)[sorted_indices]
        
        # Check for large jumps in complexity
        if len(complexities) > 1 and np.max(np.abs(np.diff(complexities))) > jump_threshold:
            print(f"Large jump detected at iteration {iteration}. Refining sampling.")
            refined_samples = refine_sampling(param_samples, complexities, jump_threshold)
            refined_samples = [p for p in refined_samples if p not in param_samples]
            refined_complexities = [compute_or_get_complexity(p) for p in refined_samples]

            # Update samples and complexities with refined data
            param_samples = np.append(param_samples, refined_samples)
            complexities = np.append(complexities, refined_complexities)

            # Sort again after refining
            sorted_indices = np.argsort(param_samples)
            param_samples = np.array(param_samples)[sorted_indices]
            complexities = np.array(complexities)[sorted_indices]
        
        # Check for low improvement and stop if necessary
        if len(complexities) > 1 and abs(complexities[-1] - complexities[-2]) < threshold:
            print(f"Low improvement detected at iteration {iteration}.")
            break

    print(f"Final param samples: {param_samples}")
    print(f"Final complexities: {complexities}")

    return param_samples, complexities


# def piecewise_quantize(param_samples, complexities, quantization_levels=4):
#     """
#     Quantize the function into a piecewise constant (square wave) representation.
#     """
#     # Sort samples and complexities by parameter value
#     sorted_indices = np.argsort(param_samples)
#     param_samples = np.array(param_samples)[sorted_indices]
#     complexities = np.array(complexities)[sorted_indices]
    
#     # Quantize complexities directly
#     coeff_min, coeff_max = np.min(complexities), np.max(complexities)
#     quantized_complexities = np.round((complexities - coeff_min) / (coeff_max - coeff_min) * (quantization_levels - 1)) / (quantization_levels - 1) * (coeff_max - coeff_min) + coeff_min
    
#     # Create piecewise constant function
#     unique_params = np.unique(param_samples)
#     piecewise_complexities = np.zeros_like(param_samples)
#     for i, param in enumerate(param_samples):
#         piecewise_complexities[i] = quantized_complexities[np.searchsorted(param_samples, param)]
    
#     # Define a new parameter range for plotting
#     param_range = np.linspace(min(param_samples), max(param_samples), num=len(unique_params))
    
#     # Generate piecewise constant complexities for the new range
#     interpolator = interp1d(param_samples, piecewise_complexities, kind='previous', fill_value='extrapolate')
#     interpolated_complexities = interpolator(param_range)
    
#     return param_range, interpolated_complexities

# def plot_piecewise_quantization(param_range, interpolated_complexities, param_samples, complexities):
#     """
#     Plot the original points and the quantized piecewise constant function.
#     """
#     # Plot the quantized piecewise constant function
#     plt.step(param_range, interpolated_complexities, where='post', label='Quantized & Piecewise Constant')
#     # Plot original samples
#     plt.scatter(param_samples, complexities, color='red', label='Original Samples')
#     plt.xlabel('Parameter')
#     plt.ylabel('Complexity')
#     plt.legend()
#     plt.title('Piecewise Quantization')
#     plt.show()


def wavelet_quantize(param_samples, complexities, wavelet='db1', level=1, quantization_levels=4, num_points=100):
    """
    Quantize the function using a discrete wavelet transform and interpolate the result.
    """
    # Sort samples and complexities by parameter value
    sorted_indices = np.argsort(param_samples)
    param_samples = np.array(param_samples)[sorted_indices]
    complexities = np.array(complexities)[sorted_indices]
    
    # Apply wavelet transform to the complexities
    coeffs = pywt.wavedec(complexities, wavelet, level=level)
    
    # Quantize the wavelet coefficients
    quantized_coeffs = []
    for coeff in coeffs:
        coeff_min, coeff_max = np.min(coeff), np.max(coeff)
        coeff_normalized = (coeff - coeff_min) / (coeff_max - coeff_min)
        quantized_coeff = np.round(coeff_normalized * (quantization_levels - 1)) / (quantization_levels - 1)
        quantized_coeff = quantized_coeff * (coeff_max - coeff_min) + coeff_min
        quantized_coeffs.append(quantized_coeff)
    
    # Reconstruct the signal from quantized coefficients
    quantized_complexities = pywt.waverec(quantized_coeffs, wavelet)
    
    # Ensure the reconstructed signal matches the length of the original complexities
    quantized_complexities = quantized_complexities[:len(complexities)]
    
    # Interpolate the quantized signal for smoother approximation
    interpolator = interp1d(param_samples, quantized_complexities, kind='cubic', fill_value='extrapolate')
    
    # Generate new points for unsampled regions or denser sampling
    param_range = np.linspace(min(param_samples), max(param_samples), num_points)
    interpolated_complexities = interpolator(param_range)
    
    return param_range, interpolated_complexities


def plot_wavelet_quantization(param_range, interpolated_complexities, param_samples, complexities):
    """
    Plot the original points and the quantized & interpolated function using wavelets.
    """
    # Plot the quantized and interpolated function
    plt.plot(param_range, interpolated_complexities, 'b-', label='Quantized & Interpolated')
    # Plot original samples
    plt.scatter(param_samples, complexities, color='red', label='Original Samples')
    plt.xlabel('Parameter')
    plt.ylabel('Complexity')
    plt.legend()
    plt.title('Wavelet Quantization')
    plt.show()


def plot_parameter_space_lorenz(param_samples, complexities, title="Parameter Space Exploration for Lorenz System"):
    """
    Visualize the parameter space exploration for the Lorenz system.
    """
    fig = plt.figure(figsize=(6, 4))
    ax = fig.add_subplot(111)
    sc = ax.scatter(param_samples, complexities, c=complexities, cmap='viridis')
    fig.colorbar(sc, label='Complexity')
    ax.set_xlabel('r')
    ax.set_ylabel('Complexity')
    plt.title(title)
    plt.show()


def find_parameters_for_target_complexity(param_samples, complexities, target_complexity, wavelet='db1', level=1, quantization_levels=4, num_points=100):
    """
    Find parameters that achieve the target complexity using the wavelet quantized function.
    """
    # Quantize the function
    param_range, quantized_complexities = wavelet_quantize(param_samples, complexities, wavelet, level, quantization_levels, num_points)
    
    # Interpolate to find parameters corresponding to the target complexity
    target_interpolator = interp1d(quantized_complexities, param_range, kind='cubic', fill_value='extrapolate')
    params_for_target = target_interpolator(target_complexity)
    
    return params_for_target

